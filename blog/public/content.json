[{"title":"寄生式组合继承能否优化？","date":"2017-04-19T16:00:00.000Z","path":"2017/04/20/寄生式组合继承能否优化/","text":"问题：寄生式组合继承能否优化？1、修改子类原型对象的引用属性，其父类的原型对象的引用属性跟着改变2、欢迎大家来指正！ JavaScript中的多种继承方式 一、混入式继承：指的是字面量1继承字面量2;a) 实现方式:遍历字面量2赋值给字面量1b) 注意点：必须用[]语法，不能用点语法c) 缺点：修改字面量1会对字面量2造成影响1234567891011121314151617181920212223 # 继承的实现(混入式继承) &lt;script&gt; var dog = &#123; name: &quot;啦啦小新&quot;, age: 20, friends: [&quot;哗啦哗啦&quot;, &quot;哔哩哔哩&quot;] &#125; //dog1 var dog1 = &#123;&#125;; //dog1 能够拥有dog对象中所有的属性和方法 //遍历dog对象,拷贝它所有的属性和方法设置到自己的身上 for (var k in dog) &#123; //使用[]语法 dog1[k] = dog[k]; &#125; console.log(dog1); //问题:修改其中的某个对象dog1,会对原对象产生影响 //为什么:引用类型的赋值(地址) dog1.friends.push(&quot;乌拉乌拉&quot;); 哗啦哗啦&quot;, &quot;哔哩哔哩&quot;，&quot;乌拉乌拉&quot;]&#125; console.log(dog); //&#123;name: &quot;啦啦小新&quot;,age: 20,friends: [&quot;哗啦哗啦&quot;, &quot;哔哩哔哩&quot;，&quot;乌拉乌拉&quot;]&#125; &lt;/script&gt; 二、原型式继承：通过设置其原型的方式继承a)实现方式：i.设置构造函数的原型对象的属性和方法（点语法），构造函数创建出来的对象自动共享原型对象中的属性和方法ii.设置构造函数的原型对象的属性和方法（字面量法），构造函数创建出来的对象自动共享原型对象中的属性和方法iii.设置子对象的原型对象为父对象的原型对象，再修正构造器，子对象构造函数创建出来的对象自动共享父对象的原型对象中的属性和方法b)注意点：使用原型替换的方式实现继承的时候,原有原型对象中的属性和方法会丢失c)缺点：i.修改一个对象的属性和方法，会影响其他的对象ii.只能继承原型属性和方法，无法继承实例属性和方法1234567891011121314 # 原型式继承A &lt;script&gt; function Animal() &#123;&#125; //设置原型对象 Animal.prototype.run = function() &#123; console.log(&quot;run&quot;); &#125; Animal.prototype.type = &quot;猫科动物&quot;; //创建对象 //性质:构造函数创建出来的所有对象都自动拥有其对于原型对象上面的所有属性和方法 var a = new Animal(); console.log(a.type); a.run(); &lt;/script&gt; 123456789101112131415161718 # 原型式继承B &lt;script&gt; var obj = &#123; name: &quot;默认的名字&quot;, age: 20 &#125;; function Animal() &#123;&#125; //设置原型对象 Animal.prototype = obj; //修正构造器属性 Animal.prototype.constructor = Animal; //创建对象 //性质:构造函数创建出来的所有对象都自动拥有其对于原型对象上面的所有属性和方法 var a = new Animal(); console.log(a.name); console.log(a.age); &lt;/script&gt; 123456789101112131415161718 # 原型式继承C &lt;script&gt; function Animal() &#123;&#125; //设置原型对象 Animal.prototype.run = function() &#123; console.log(&quot;run&quot;); &#125; function Dog() &#123;&#125; //设置原型 Dog.prototype = Animal.prototype; //创建对象 var dog = new Dog(); dog.run(); //问题: //001 Dog 的原型对象和Animal的原型对象是同一个,不论是谁修改了原型对象会影响到另外一个 //002 只能继承Animal的原型属性和方法,无法得到其实例属性和方法 &lt;/script&gt; 三、原型链继承：是通过原型链的方式继承a)实现方式：i.设置子对象的原型对象为 new 父对象构造函数ii.子对象构造函数创建出来的对象自动共享父对象中的属性和方法（实例和原型属性和方法）;b)注意点：i.设置原型链继承必须在设置子对象的属性和方法之前ii.如果设置同名的实例属性或方法，会覆盖父对象中的属性和方法iii.设置原型链继承之后,需要修正构造器属性指向iv.完成继承后再以字面量的方式设置子对象原型，会断开继承c)缺点：i.修改一个对象的属性和方法，会影响其他的对象ii.无法对父对象进行传参12345678910111213141516171819202122232425 # 构造函数A - B &lt;script&gt; //01 提供两个构造函数 //02 设置A构造函数的原型对象的属性和方法 //03 设置原型链继承 //04 创建B类型的对象 使用B构造函数来创建对象 function A() &#123; this.description = &quot;描述信息&quot;; this.logDes = function() &#123; console.log(this.description); &#125; &#125; A.prototype.name = &quot;A的默认名称&quot;; A.prototype.showName = function() &#123; console.log(this.name); &#125; function B() &#123;&#125;; B.prototype = new A(); //完成继承 B.prototype.constructor = B; //修正构造器 var b1 = new B(); console.log(b1.name); //A的默认名称 b1.showName(); //A的默认名称 b1.logDes(); //描述信息 &lt;/script&gt; 四、借用构造函数继承：是指通过借用别人的方法或属性来实现继承a)实现方式：i.子对象构造函数中设置：父对象构造函数.call/apply(this,参数);ii.子对象构造函数创建出来的对象自动共享父对象中的实例属性和方法（实例属性和方法）;b)注意点：call和apply方法会改变this的指向，谁调用就指向谁c)缺点：只能继承实例属性和方法，无法继承原型属性和方法123456789101112131415161718192021222324252627&lt;script&gt; //01 提供父类型的构造函数 function SuperType(name) &#123; //02 在构造函数中中设置实例属性,该属性为引用类型 this.family = [&apos;哥哥&apos;, &apos;姐姐&apos;, &apos;爸爸&apos;, &apos;妈妈&apos;]; //实例属性 this.name = name; &#125;; //03 提供子类型的构造函数 function SubType() &#123; //经典继承|借用构造函数|伪造对象继承 //SuperType.call(this); //构造参数传递参数 SuperType.call(this, &apos;张老汉&apos;); &#125;; //04 创建父类型的实例对象,并对内部的实例化属性进行修改 var subDemo1 = new SubType(); var subDemo2 = new SubType(); console.log(subDemo1); alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈 alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈 subDemo1.family.push(&apos;爷爷&apos;, &apos;奶奶&apos;); alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈,爷爷,奶奶 alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈 //测试构造函数传递参数 alert(subDemo1.name); &lt;/script&gt; 五、组合继承：是指借用构造函数继承和原型式继承的组合a)实现方式：i.子对象构造函数中设置：父对象构造函数.call/apply(this,参数);ii.设置子对象的原型对象为父对象的原型对象;iii.修正子对象的构造器；iv.子对象构造函数创建出来的对象自动共享父对象中的属性和方法（实例和原型属性和方法）;b)注意点：call和apply方法是伪继承 /没有继承关系 只是把Person构造函数的属性和方法深复制一份（包括引用类型：指针和堆空间的数据）c)缺点：修改子类原型方法和原型引用属性,父类原型方法和原型引用属性也跟着变123456789101112131415161718192021222324252627282930 &lt;script&gt;/*该继承缺点:修改子类原型的方法,父类原型方法也跟着变，其*/function Person(name) &#123; this.name = name;&#125;Person.prototype.age = 12;Person.prototype.arr = [1,2,3];Person.prototype.play = function() &#123; console.log(this.name + &quot;playfooterball&quot;);&#125;function Student(name) &#123; Person.call(this, name); /*伪继承 没有继承关系 只是把Person构造函数的属性和方法深复制一份（包括引用类型：指针和堆空间的数据）*/&#125;Student.prototype = Person.prototype;Student.constructor = Student;Student.prototype.play = function() &#123; console.log(this.name + &quot;playbasketball&quot;);&#125;var s1 = new Student(&quot;漳卅&quot;);s1.arr.push(4);console.log(s1); //Student对象console.log(s1.age); //12console.log(s1.arr);s1.play(); // 漳卅playbasketballvar p = new Person(&quot;郭嘉&quot;);p.play(); // 郭嘉playbasketballconsole.log(p.arr);&lt;/script&gt; 六、寄生组合式继承：优化了组合继承中的修改子类原型方法,父类原型方法也跟着变的缺点a)实现方法：i.只需把组合继承中的设置子对象的原型对象为父对象的原型对象这一句;ii.修改为子对象的原型对象为object.create(父对象的原型对象);就OK了12345678910111213141516171819202122232425262728&lt;script&gt;function Person(name) &#123; this.name = name;&#125; Person.prototype.age = 12;Person.prototype.play = function () &#123; console.log(this.name + &quot;playfooterball&quot;);&#125;Person.prototype.arr = [1,2,3];function Student(name) &#123; Person.call(this,name);/*伪继承 没有继承关系 只是把Person构造函数的属性和方法深复制一份（包括引用 类型：指针和堆空间的数据）*/&#125;Student.prototype = Object.create(Person.prototype);Student.constructor = Student;Student.prototype.play = function()&#123; console.log(this.name + &quot;playbasketball&quot;);&#125;var s1 = new Student(&quot;漳卅&quot;);s1.arr.push(4);console.log(s1);//漳卅console.log(s1.age);//12Console.log(s1.arr);//[1,2,3,4]s1.play();//漳卅 playbasketballvar p = new Person(&quot;郭嘉&quot;);p.play();//郭嘉 playfooterballconsole.log(p.arr);//[1,2,3,4]&lt;/script&gt; 上述代码：修改子类的原型引用类属性，其父类的原型引用类属性跟着改变！","tags":[{"name":"Object","slug":"Object","permalink":"http://yoursite.com/tags/Object/"}]},{"title":"VS Code 的常用快捷键和插件","date":"2017-04-08T16:00:00.000Z","path":"2017/04/09/vs code 的常用快捷键和常用插件/","text":"VS Code 的常用快捷键和插件 一、vs code 的常用快捷键 1、注释： a) 单行注释：[ctrl+k,ctrl+c] 或 ctrl+/ b) 取消单行注释：[ctrl+k,ctrl+u] (按下ctrl不放，再按k + u) c) 多行注释：[alt+shift+A] d) 多行注释：/**2、移动行：alt+up/down 3、显示/隐藏左侧目录栏 ctrl + b 4、复制当前行：shift + alt +up/down 5、删除当前行：shift + ctrl + k 6、控制台终端显示与隐藏：ctrl + ~ 7、查找文件/安装vs code 插件地址：ctrl + p 8、代码格式化：shift + alt +f 9、新建一个窗口 : ctrl + shift + n 10、行增加缩进: ctrl + [ 11、行减少缩进: ctrl + ] 12、裁剪尾随空格(去掉一行的末尾那些没用的空格) : ctrl + shift + x 13、字体放大/缩小: ctrl + ( + 或 - ) 14、拆分编辑器 : ctrl + 1/2/3 15、切换窗口 : ctrl + shift + left/right 16、关闭编辑器窗口 : ctrl + w 17、关闭所有窗口 : ctrl + k + w 18、切换全屏 : F11 19、自动换行 : alt + z 20、显示git : ctrl + shift + g 二、vs code 的常用插件 1、Auto Rename Tag 修改html标签，自动帮你完成尾部闭合标签的同步修改，和webstorm一样。 2、Auto Close Tag 自动闭合HTML标签 4、Beautiful 格式化代码的工具 5、Dash Dash是MacOS的API文档浏览器和代码段管理器 6、Ejs Snippets ejs 代码提示 7、ESLint 检查javascript语法错误与提示 8、File Navigator 快速查找文件 9、Git History(git log) 查看git log 10、Gulp Snippets 写gulp时用到，gulp语法提示。 11、HTML CSS Support 在HTML标签上写class智能提示当前项目所支持的样式 12、HTML Snippets 超级好用且初级的H5代码片段以及提示 13、Debug for Chrome 让vs code映射chrome的debug功能，静态页面都可以用vscode来打断点调试、配饰稍微复杂一点 14、Document this Js的注释模板 15、jQuery Code Snippets jquery提示工具 16、Html2jade html模板转pug模板 17、JS-CSS-HTML Formatter 格式化 18、Npm intellisense require 时的包提示工具 19、Open in browser 打开默认浏览器 20、One Dark Theme 一个vs code的主题 21、Path Intellisense 自动路径补全、默认不带这个功能 22、Project Manager 多个项目之间快速切换的工具 23、Pug(Jade) snippets pug语法提示 24、React Components 根据文件名创建反应组件代码。 25、React Native Tools reactNative工具类为React Native项目提供了开发环境。 26、Stylelint css/sass代码审查 27、Typings auto installer 安装vscode 的代码提示依赖库，基于typtings的 28、View In Browser 默认浏览器查看HTML文件（快捷键Ctrl+F1可以修改） 29、Vscode-icons 让vscode资源目录加上图标、必备 30、VueHelper Vue2代码段（包括Vue2 api、vue-router2、vuex2） 31、Vue 2 Snippets vue必备vue代码提示 32、Vue-color vue语法高亮主题","tags":[{"name":"VS Code","slug":"VS-Code","permalink":"http://yoursite.com/tags/VS-Code/"}]},{"title":"Angular 中的常用指令和常用服务","date":"2017-03-17T16:00:00.000Z","path":"2017/03/18/Angular 中的常用指令/","text":"Angular 中的常用指令1、Ng-app 模块入口指令 指令定义了 AngularJS 应用123456789101112131415&lt;body&gt; &lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myCtr&quot;&gt; 名：&lt;input type=&quot;text&quot; ng-model=&quot;firstName&quot;&gt; 姓：&lt;input type=&quot;text&quot; ng-model =&quot;lastName&quot;&gt; &lt;br&gt; 姓名：&#123;&#123;lastName + &quot;&quot;+ firstName&#125;&#125; &lt;/div&gt; &lt;script&gt; var app = angular.module(&apos;myApp&apos;,[]); app.controller(&apos;myCtr&apos;,function ($scope) &#123; $scope.firstName = &apos;john&apos;; $scope.lastName = &apos;Doe&apos;; &#125;) &lt;/script&gt;&lt;/body&gt; Ng-app的作用域为当前div 2、Ng-controller 控制器（功能入口指令）指令定义了应用控制器123456789101112131415&lt;body&gt; &lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myCtr&quot;&gt; 名：&lt;input type=&quot;text&quot; ng-model=&quot;firstName&quot;&gt; 姓：&lt;input type=&quot;text&quot; ng-model =&quot;lastName&quot;&gt; &lt;br&gt; 姓名：&#123;&#123;lastName + &quot;&quot;+ firstName&#125;&#125; &lt;/div&gt; &lt;script&gt; var app = angular.module(&apos;myApp&apos;,[]); app.controller(&apos;myCtr&apos;,function ($scope) &#123; $scope.firstName = &apos;john&apos;; $scope.lastName = &apos;Doe&apos;; &#125;) &lt;/script&gt;&lt;/body&gt; Ng-controller的作用域为当前div 3、Ng-show 展示指令，返回值为boolean123456789101112131415161718192021222324&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;angular.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app = angular.module(&apos;myApp&apos;,[]); app.controller(&apos;myCtrl&apos;,[&apos;$scope&apos;,function ($scope) &#123; $scope.students = [&apos;zs&apos;,&apos;lisi&apos;,&apos;wangwu&apos;]; $scope.isShow = true; $scope.isShow = 1; &#125;]); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;ul ng-app = &quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt; &lt;li ng-repeat=&quot;x in students&quot;&gt;&#123;&#123;x&#125;&#125;&lt;/li&gt; &lt;li ng-repeat=&quot;x in students&quot; ng-show=&quot;false&quot;&gt;&#123;&#123;x&#125;&#125;&lt;/li&gt; &lt;li ng-repeat=&quot;x in students&quot; ng-hide=&quot;true&quot;&gt;&#123;&#123;x&#125;&#125;&lt;/li&gt; &lt;li ng-repeat=&quot;x in students&quot; ng-show=&quot;isShow&quot;&gt;&#123;&#123;x&#125;&#125;&lt;/li&gt; &lt;li ng-repeat=&quot;x in students&quot; ng-if=&quot;false&quot;&gt;&#123;&#123;x&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 4、Ng-hide 隐藏指令，返回值为boolean同上代码5、Ng-if 隐藏标签指令，返回值为boolean同上代码 6、Ng-click 点击事件指令12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;angular.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app = angular.module(&apos;myApp&apos;,[]); app.controller(&apos;myCtrl&apos;,[&apos;$scope&apos;,function ($scope) &#123; $scope.click = function () &#123; alert(100); &#125;; &#125;]); &lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt; &lt;p ng-click=&quot;click()&quot;&gt;点我&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 7、Ng-mouseover 鼠标移上指令8、Ng-事件名 事件指令9、数据绑定 （有闪烁）12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;angular.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app = angular.module(&apos;myApp&apos;,[]); app.controller(&apos;myCtrl&apos;,[&apos;$scope&apos;,function ($scope) &#123; $scope.name = &apos;jhon&apos;; $scope.age = 18; &#125;]); &lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt; &lt;ul&gt; &lt;li ng-bind=&quot;name&quot;&gt;&lt;/li&gt; &lt;li ng-bind-template=&quot;&#123;&#123;name&#125;&#125; &#123;&#123;age&#125;&#125;&quot;&gt;&lt;/li&gt; &lt;li ng-cloak&gt;&#123;&#123;name&#125;&#125; &#123;&#123;age&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 10、Ng-bind 单数据绑定指令（无闪烁）同上代码 11、Ng-bind-template 多数据绑定指令（无闪烁）同上代码 12、Ng-cloak 多数据绑定指令（无闪烁）同上代码 13、Ng-class 操控类名指令12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .red&#123; color: #f60; &#125; .font&#123; font-size:60px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body ng-app=&quot;myApp&quot;&gt;&lt;div ng-class=&quot;&#123;red:true,font:true&#125;&quot;&gt;hello&lt;/div&gt;&lt;div ng-style=&quot;sty&quot;&gt;hello&lt;/div&gt;&lt;script src=&quot;angular.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var app = angular.module(&apos;myApp&apos;,[]); app.controller(&apos;myCtrl&apos;,[&apos;$scope&apos;,function ($scope) &#123; $scope.sty = &#123; &apos;color&apos;:&apos;red&apos; &#125; &#125;]);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 14、Ng-style 操控样式指令12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;angular.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app = angular.module(&apos;myApp&apos;,[]); app.controller(&apos;myCtrl&apos;,[&apos;$scope&apos;,function ($scope) &#123; $scope.sty = &#123; &apos;color&apos;:&apos;red&apos; &#125; &#125;]); &lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt; &lt;p ng-style=&quot;sty&quot;&gt;hello&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 15、Ng-src 操控图片地址123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app = angular.module(&apos;myApp&apos;,[]); app.controller(&apos;myCtrl&apos;,[&apos;$scope&apos;,function ($scope) &#123; $scope.url = &quot;image/03.jpg&quot;; &#125;]); &lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt;&lt;img ng-src=&quot;&#123;&#123;url&#125;&#125;&quot; alt=&quot;&quot;&gt;&lt;/body&gt;&lt;/html&gt; 16、Ng-href 操控a标签地址1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;angular.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app = angular.module(&apos;myApp&apos;,[]); app.controller(&apos;myCtrl&apos;,[&apos;$scope&apos;,function ($scope) &#123; $scope.url = &quot;www.baidu.com&quot;; &#125;]); &lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt;&lt;a ng-href=&quot;url&quot;&gt;a&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 17、Ng-include 插入模块指令123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body ng-app=&quot;myApp&quot;&gt; &lt;div ng-include=&quot;&apos;./head.html&apos;&quot;&gt;&lt;/div&gt; &lt;div ng-include=&quot;&apos;./body.html&apos;&quot;&gt;&lt;/div&gt; &lt;div ng-include=&quot;&apos;./foot.html&apos;&quot;&gt;&lt;/div&gt; &lt;img ng-src=&quot;url&quot; alt=&quot;&quot;&gt;&lt;script src=&quot;angular.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var app = angular.module(&apos;myApp&apos;,[]); app.controller(&apos;myCtrl&apos;,[&apos;$scope&apos;,function ($scope) &#123; $scope.url = &quot;mengxiang.png&quot;; &#125;]);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 18、Ng-model 绑定数据（相当于$scope对象创建属性）1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myCtr&quot;&gt; 名字：&lt;input ng-model = &quot;name&quot;&gt; &lt;h1&gt;你输入了：&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; var app = angular.module(&apos;myApp&apos;,[]); app.controller(&apos;myCtr&apos;,function ($scope) &#123; $scope.name = &apos;dap&apos;; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 19、Ng-init 设置默认数据指令12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-app=&quot;&quot; ng-init=&quot;firstName = &apos;john&apos;&quot;&gt; &lt;p&gt;姓名：&lt;span ng-bind=&quot;firstName&quot;&gt;&lt;/span&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 20、Ng-Repeat 遍历数据指令1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-app =&quot;&quot; ng-init=&quot;names=[&#123;name:&apos;jhon&apos;,country:&apos;Norway&apos;&#125;,&#123;name:&apos;hege&apos;,country:&apos;sweden&apos;&#125;,&#123;name:&apos;doe&apos;,country:&apos;denmark&apos;&#125;]&quot;&gt; &lt;p&gt;循环对象：&lt;/p&gt; &lt;ul&gt; &lt;li ng-repeat =&quot;x in names&quot;&gt;&#123;&#123;x.name + &apos;,&apos; + x.country&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Ng-repeat=”value in 自定义数据名” 21、Ng-options 遍历数据指令（用于下拉菜单数据遍历）123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;https://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div ng-app=&quot;myApp&quot; ng-controller=&quot;myCtrl&quot;&gt; &lt;select ng-init=&quot;selectedName = names[0]&quot; ng-model=&quot;selectedName&quot; ng-options=&quot;x for x in names&quot;&gt; &lt;/select&gt; &lt;p&gt;该实例演示了使用 ng-options 指令来创建下拉列表。&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var app = angular.module(&apos;myApp&apos;,[]); app.controller(&apos;myCtrl&apos;,function ($scope) &#123; $scope.names = [&apos;Google&apos;,&apos;Runoob&apos;,&apos;Taobao&apos;]; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 22、Ng-checked12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;https://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;&quot;&gt; &lt;p&gt;My cars:&lt;/p&gt; &lt;input type=&quot;checkbox&quot; ng-model = &quot;all&quot;&gt;Check all &lt;br&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot; ng-checked=&quot;all&quot;&gt;Volvo &lt;br&gt; &lt;input type=&quot;checkbox&quot; ng-checked=&quot;all&quot;&gt;Ford &lt;br&gt; &lt;input type=&quot;checkbox&quot; ng-checked=&quot;all&quot;&gt;Mercedes &lt;br&gt; &lt;p&gt;点击Check all 选择所有的车&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 23、Ng-disabled24、Ng-readonly25、Ng-submit 使用angular监听表单提交，用在form上26、Ng-open 返回值为boolean 常用于details标签，用作显示隐藏27、Ng-cut 剪切事件12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;https://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;&quot;&gt;&lt;input type=&quot;text&quot; ng-cut=&quot;count=count+1&quot; ng-init=&quot;count=0&quot; value=&quot;拷贝&quot;&gt;&lt;p&gt;文本被剪切&#123;&#123;count&#125;&#125;次。&lt;/p&gt;&lt;p&gt;实例中变量count的值在输入框的文本被剪切时会自动增加1.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 28、Ng-copy 拷贝事件12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;https://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;&quot;&gt;&lt;input type=&quot;text&quot; ng-copy=&quot;count=count+1&quot; ng-init=&quot;count=0&quot; value=&quot;拷贝&quot;&gt;&lt;p&gt;文本被拷贝&#123;&#123;count&#125;&#125;次。&lt;/p&gt;&lt;p&gt;实例中变量count的值在输入框的文本被拷贝时会自动增加1.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 29、Ng-paste 粘贴事件30、Ng-change 内容改变时执行1234567891011121314151617181920212223&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;https://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;app&quot; ng-controller=&quot;myCtrl&quot;&gt;&lt;div&gt; &lt;p&gt;在输入框中输入一些信息：&lt;/p&gt; &lt;input type=&quot;text&quot; ng-change=&quot;myFunc()&quot; ng-model=&quot;myValue&quot;&gt; &lt;p&gt;输入框已经修改了&#123;&#123;count&#125;&#125;次。&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var app = angular.module(&apos;app&apos;,[]); app.controller(&apos;myCtrl&apos;,[&apos;$scope&apos;,function ($scope) &#123; $scope.count = 0; $scope.myFunc = function () &#123; $scope.count ++; &#125; &#125;]);&lt;/script&gt;&lt;/html&gt; 31、Ng-class-even 在偶数行起作用的css类123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .striped&#123; color: white; background-color: black; &#125; &lt;/style&gt; &lt;script src=&quot;https://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;app&quot; ng-controller=&quot;myCtrl&quot;&gt;&lt;table&gt; &lt;tr ng-repeat=&quot;x in records&quot; ng-class-even=&quot;&apos;striped&apos;&quot;&gt; &lt;td&gt;&#123;&#123;x.Name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;x.Country&#125;&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;script&gt; var app = angular.module(&apos;app&apos;,[]); app.controller(&apos;myCtrl&apos;,[&apos;$scope&apos;,function ($scope) &#123; $scope.records = [ &#123; &quot;Name&quot; : &quot;Alfreds Futterkiste&quot;, &quot;Country&quot; : &quot;Germany&quot; &#125;, &#123; &quot;Name&quot; : &quot;Berglunds snabbk&quot;, &quot;Country&quot; : &quot;Sweden&quot; &#125;, &#123; &quot;Name&quot; : &quot;Centro comercial Moctezuma&quot;, &quot;Country&quot; : &quot;Mexico&quot; &#125;, &#123; &quot;Name&quot; : &quot;Ernst Handel&quot;, &quot;Country&quot; : &quot;Austria&quot; &#125; ] &#125;]);&lt;/script&gt;&lt;/html&gt; 32、Ng-model-options 规定如何更新模型33、ng-non-bindable 规定元素不能绑定数据1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script src=&quot;https://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-app=&quot;&quot;&gt; &lt;p&gt;使用 AngularJS: &#123;&#123; 5+5 &#125;&#125;&lt;/p&gt; &lt;p ng-non-bindable&gt;不使用 AngularJS: &#123;&#123; 5+5 &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;p&gt;如果你不想使用 AngularJS 执行表达式可以使用 ng-non-bindable 。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 34、ng-transclude 一般用在自定义指令中模板中，使其替换的标签内部的子元素嵌套在模板中，并且自定义指令必须有transclude:true 35、自定义指令12345678910111213141516App.directive(‘name’,[‘依赖模块’,function()&#123; Return &#123; Restrict:’EAMC’, Replace:true, Template/templateUrl:’’, Controller:function()&#123;&#125;, Scope:true/false/&#123; Data:’@’或 //常量 单向传递 Data:’=’或 //变量 双向绑定 Data:’&amp;’ //回掉函数 &#125;,默认false，子父级在同一个作用域；true子父级作用域分离；&#123;&#125;子父级作用域相对独立 Link:function(scope,element.attrs)&#123; &#125; &#125;&#125;]); 一般用法Angular.forEach() 对象或数组的迭代函数Angular.copy() 数组或者对象的深度拷贝Angular.equals() 如果两个对象相等返回trueAngular.fromJson() 反序列化JSON字符串Angular.toJson() 序列化JSON字符串Angular.bootstrap() 手动启动AngularJsAngular.element() 把DOM元素转换为jQuery对象 Angular的常用服务1、$httpAngular-1.5x版本123456789101112131415161718192021222324252627282930313233343536&lt;script src=&quot;angular.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;app&quot; ng-controller=&quot;myCtrl&quot;&gt;&lt;/body&gt;&lt;script&gt; var app = angular.module(&apos;app&apos;,[]); app.controller(&apos;myCyrl&apos;,[&apos;$scope&apos;,&apos;$http&apos;,function ($scope,$http) &#123; $http(&#123; url:&apos;get.php&apos;, method:&apos;get&apos;, params:&#123; name:&apos;jhon&apos; &#125; &#125;).success(function (res) &#123; &#125;).error(function (err) &#123; &#125;);/* $http(&#123; url:&apos;post.php&apos;, method:&apos;post&apos;, headers:&#123; &apos;Content-Type&apos;:&apos;application/x-www-form-urlencoded&apos; &#125;, params:&#123; &#125;, data:&quot;name=xmg&quot; &#125;).success(function (res) &#123; alert(res); &#125;).error(function (res) &#123; alert(res); &#125;);*/ &#125;]);&lt;/script&gt; Angular-1.6x版本123456789101112131415161718192021&lt;script src=&quot;angular.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app=&quot;app&quot; ng-controller=&quot;myCtrl&quot;&gt;&lt;/body&gt;&lt;script&gt; var app = angular.module(&apos;app&apos;,[]); app.controller(&apos;myCyrl&apos;,[&apos;$scope&apos;,&apos;$http&apos;,function ($scope,$http) &#123; $http(&#123; url:&apos;get.php&apos;, method:&apos;get&apos;, params:&#123; name:&apos;jhon&apos; &#125; &#125;).then(function (res) &#123; alert(res.data);//返回的是对象，其对象的data才是结果 &#125;).catch(function (err) &#123; &#125;); &#125;]);&lt;/script&gt; 2、$log 日志输出$log.log()$log.error()$log.warn()$log.info()$log.debug() 3、$location 地址$location.absUrl() 绝对地址$location.url() 锚点后的地址$location.port() 端口$location.host() 主机$location.hash() 锚点$location.search() 获取搜索地址$location.protocol() 协议 4、$filter 过滤器12$filter(‘currency’);Currency、orderBy、uppercase、lowercase、limitTo、date、number、filter、json 5、$watch 监听内容改变1$watch(‘监听对象’,function(new,old)&#123;&#125;,true/false)；true是深监听，不单纯监听地址，也监听引用类型内部的值的改变 6、$q 延迟执行123456789$q.defer()延迟执行$http(&#123;&#125;) .then($q.defer().resolve(res)) .catch($q.defer().reject(err))$q.promise();$q.when(fn1()).then() 顺序执行$q.all([fn1(),fn2()]).then(结果) 同时执行 7、$timeout8、$interval9、自定义服务1234567891011121314151617181920212223242526272829303132//工厂App.factory(‘name’,function()&#123; Return &#123;&#125;或function()&#123;&#125;&#125;);//服务App.service(‘name’,function()&#123; This.fn = function()&#123;&#125; 或 This.age = num;&#125;);//常量App.value(‘name’,12); 定义常量``` 10、配置块```scriptApp.config(‘$logProvider’,function($logProvider)&#123;&#125;);1、$logProvider.debugEnabled();禁用debug输出2、filterProvider.register(‘name’,function()&#123;&#125;);注册过滤器3、$routeProvider.when(‘url’,&#123; Template:’’ &#125;).otherwise(&#123; redirectTo:’’&#125;);4、$sceDelegateProvider 跨域配置白名单$sceDelegateProvider.resourceUrlWhitelist([ &apos;http://c.runoob.com/runoobtest/**&apos;]); 11、运行块1App.run([‘依赖模块’,function()&#123;&#125;]); 12、控制器123456App.controller(‘name’,[‘$scope’,function($scope)&#123; $scope.$broadcast(‘name’,&#123;参数&#125;);//父元素向子元素广播一个事件，但其必须放在事件中，不然会立即执行 $scope.$on(‘name’,function(event,data)&#123;&#125;);//这个是在子元素对应的控制器中 $scope.$emit(‘name’,&#123;参数&#125;);子元素向父元素广播一个事件，但其必须放在事件中，不然会立即执行 $scope.$on(‘name’,function(event,data)&#123;&#125;);//这个是在父元素对应的控制器中&#125;]); 13、路由1、angular-route12345678App.config(‘$routeProvider’,[function($routeProvider)&#123; $routeProvider.when(‘url/:id’,&#123; Template:’’ &#125;).otherwise(&#123; redirectTo:’url/参数’ &#125;);&#125;]); 2、angular-ui-router1234567App.config(‘$stateProvider’,’$urlRouterProvider’,[function($routePro vider,$urlRouterProvider)&#123; $routeProvider.state(‘name’,&#123;//name别名 Url:’url/:id’, Template:’’ &#125;); $urlRouterProvider.otherwise(name);&#125;]); 14、验证 $invalid 非法字符$valid 有效字符$dirty 有填写表单$pristine 没有填写表单$error 错误novalidate 属性规定当提交表单时不对其进行验证。","tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"}]},{"title":"JavaScript中关于变量与函数的提升","date":"2017-02-21T16:00:00.000Z","path":"2017/02/22/promotion/","text":"在javascript中关于变量与函数的提升一、简介在javascript中声明变量与函数的执行步骤:1、先预解析变量或函数声明代码，会把用var声明的变量或者函数声明的代码块进行提升操作2、然后再进行执行操作 关于变量声明提升:用var声明的变量提升,其只是变量提升了，而没有进行赋值的提升 二、关于变量与函数提升的注意点1、变量提升的代码演示1234567891011121314var a = 10;console.log(a);//10console.log(b);// undefinedvar b = 20;console.log(b);//20/*变量提升演示*/var a; // 变量提升 只提升不赋值var b;// 变量提升 只提升不赋值a = 10; // 赋值操作console.log(a);// 10console.log(b);// 由于b还没有赋值，所以 undefinedb = 20; // 赋值操作console.log(b);// 20 2、两函数名相同的情况下，后面的函数声明会覆盖前面的函数声明1234567891011121314151617181920var a = 10;var b = 20; function funcName() &#123; console.log(a); &#125; function funcName()&#123; console.log(b); &#125; funcName();// 20 /*变量与函数提升演示*/ var a; var b; function funcName()&#123;//后面的覆盖了前面的函数声明 console.log(b); &#125; a = 10; b = 20; funcName(); // 20 3、变量名与函数名相同的情况下，只会提升函数声明，而不提升变量声明123456789101112131415161718192021var a = 10; function funcName() &#123; console.log(a); &#125;funcName();// 10var funcName = &apos;字符串&apos;; console.log(funcName);// 字符串funcName();// Uncaught TypeError:funcName is not a function /*变量与函数提升演示*/var a;function funcName() &#123; console.log(a);&#125;a = 10;funcName();// 10var funcName = &apos;字符串&apos;;// 与函数同名变量声明忽略提升console.log(funcName);// 字符串//由于重新给funcName赋值，funcName是一个字符串了，而不是函数，无法调用console.log(typeof funcName);// stringfuncName();// Uncaught TypeError:funcName is not a function 4、用函数表达式声明函数时，函数声明提升，只会提升变量，而不是整个函数提升1234567891011say()//Uncaught TypeError: say is not a functionvar say = function() &#123; console.log(&apos;hello&apos;);&#125;;/*函数声明演示*/var say;// 函数表达式声明函数，只提升变量say();// Uncaught TypeError: say is not a functionsay = function () &#123; console.log(&apos;hello&apos;);&#125;; 5、变量与函数的提升是分作用域的1234567891011121314151617181920212223242526272829function sayHello() &#123; console.log(&apos;hello&apos;);// hello function sayHi() &#123; console.log(a); // 10 console.log(b); // undefined &#125; sayHi(); var b = 10;&#125;var a = 10;sayHello();console.log(b);// Uncaught ReferenceError: b is not defined/*函数与变量提升演示*/function sayHello() &#123; function sayHi() &#123; console.log(a); // 10 a是全局变量，函数内部可以访问 console.log(b); // undefined &#125; var b; console.log(&apos;hello&apos;);// hello sayHi();//调用时b还没有赋值，所以undefined b = 10;&#125;var a;a = 10;sayHello();// 函数调用// b 是局部变量，函数之外无法访问console.log(b);// Uncaught ReferenceError: b is not defined 三、关于函数提升与变量提升的测试题第一题123456function show() &#123; var a = 123; console.log(a); //?&#125;show();console.log(a); //? 第二题1234567var str = &quot;string&quot;;show();function show() &#123; console.log(str); //？ var str = &quot;字符串&quot;; console.log(str); //？&#125; 第三题1234if(&quot;a&quot; in window)&#123; var a = 10;&#125;console.log(a); // ? 第四题1234567function show()&#123; if(&quot;a&quot; in window)&#123; var a = 10; &#125; console.log(a); // ?&#125;show(); 第五题123456789var a = 1;function show() &#123; if(!a) &#123; var a = 10; &#125; console.log(a); //?&#125;show(); 第六题12345678910111213141516function Foo() &#123; getName = function()&#123; alert(1); &#125;; return this;&#125;Foo.getName = function() &#123; alert(2); &#125;;Foo.prototype.getName = function()&#123; alert(3); &#125;;var getName = function() &#123; alert(4); &#125;;function getName()&#123; alert(5); &#125;Foo.getName(); // ?getName(); // ?Foo().getName(); // ?getName(); // ?new Foo.getName(); // ?new Foo().getName(); // ?new new Foo().getName(); // ? 四、 答案第一题1234567891011121314function show() &#123; var a = 123; console.log(a); //123&#125;show();console.log(a); //Uncaught ReferenceError: a is not defined(未定义)/*变量提升演示*/function show() &#123; var a; a = 123; console.log(a); //123&#125;show();console.log(a); //Uncaught ReferenceError: a is not defined(未定义) 第二题1234567891011121314151617var str = &quot;string&quot;;show();function show() &#123; console.log(str); //undefined var str = &quot;字符串&quot;; console.log(str); //字符串&#125;/*变量提升演示*/var str;function show() &#123; var str; console.log(str); //undefined str = &quot;字符串&quot;; console.log(str); //字符串&#125;str = &quot;string&quot;;show(); 第三题12345678910if(&quot;a&quot; in window)&#123; var a = 10;&#125;console.log(a); // 10/*变量提升演示*/var a;// 全局变量if(&quot;a&quot; in window)&#123; // true a = 10;&#125;console.log(a); // 10 第四题12345678910111213141516function show()&#123; if(&quot;a&quot; in window)&#123; var a = 10; &#125; console.log(a); // undefined&#125;show();/*变量提升演示*/function show()&#123; var a;// 局部变量 不是全局变量 if(&quot;a&quot; in window)&#123;// false a = 10; &#125; console.log(a); // undefined&#125;show(); 第五题12345678910111213141516171819202122 var a = 1; function show() &#123; if(!a) &#123; var a = 10; &#125; console.log(a); // 10 &#125; show(); /*变量提升演示*/var a;function show() &#123; var a; if(!a)// Blooean(undefined) == false !a == true &#123; a = 10; &#125; console.log(a); // 10&#125;a = 1;show(); 第六题12345678910111213141516171819202122232425262728293031323334353637function Foo() &#123; getName = function()&#123; alert(1); &#125;; return this;&#125;Foo.getName = function() &#123; alert(2); &#125;;Foo.prototype.getName = function()&#123; alert(3); &#125;;var getName = function() &#123; alert(4); &#125;;function getName()&#123; alert(5); &#125;Foo.getName(); // 2getName(); // 4Foo().getName(); // 1getName(); // 1new Foo.getName(); // 2new Foo().getName(); // 3new new Foo().getName(); // 3/*函数与变量提升演示*/function Foo() &#123; getName = function()&#123; alert(1); &#125;;// return this;&#125;var getName;//function getName()&#123; alert(5); &#125;//被 getName = function() &#123; alert(4); &#125;;覆盖Foo.getName = function() &#123; alert(2); &#125;;//构造函数的静态方法Foo.prototype.getName = function()&#123; alert(3); &#125;;// 原型方法getName = function() &#123; alert(4); &#125;;Foo.getName(); // 2 构造函数调用自己的静态方法//getName = function()&#123; alert(1); &#125;; 覆盖 getName = function() &#123; alert(4); &#125;;getName(); // 4 window.getName(); 5已经被4覆盖Foo().getName(); // 1 Foo()中this指向window，方法调用把getName = function() &#123; alert(4); &#125;;用getName = function()&#123; alert(1); &#125;;覆盖getName(); // 1 window.getName() 就是调用getName = function()&#123; alert(1); &#125;;new Foo.getName(); // 2 Foo.getName() 构造函数调用自己的静态方法 new 2 == 2new Foo().getName(); // 3 (new Foo()).getName() 对象调用原型方法new new Foo().getName(); // 3 new 3 == 3","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript中闭包的作用和简单的用法","date":"2017-02-17T16:00:00.000Z","path":"2017/02/18/closure/","text":"在JavaScript中闭包的作用和简单的用法一、闭包的简介作用域链:在js中只有函数有作用域的概念，由于函数内能访问函数外部的数据，而函数外部不能访问函数内部的数据，由上述形成一种作用域访问的链式结构叫做作用域链。 闭包：通过某种方式实现的一个封闭的、包裹的对外不公开的结构|空间，有人称之为封闭空间，以及匿名函数自调。闭包可以使函数外部访问函数内部的数据。 二、闭包的基本写法1、通过return来访问函数内部的变量 (function(){var a = 10; return 变量 | 函数 }); 2、通过立即执行函数访问函数内部的变量 01、 (function(){})();// 常用 02、 (function(){}());// 常用 03、 ;function(){}(); 04、 +function(){}(); 05、 -function(){}(); 三、闭包的作用1、闭包的作用 01、提供一种间接访问函数内部变量的方法 02、延长函数内部的局部变量的生命周期(慎用！局部变量过多会占大量内存) 03、全局变量私有化，减少全局变量污染 04、函数局部变量在函数执行完后释放内存(函数执行完毕，其内部的变量立即销毁) 05、更新复杂变量(可以对变量进行校验和判断，保证安全性和稳定性) 2、代码示例 01、提供一种间接访问函数内部变量的方法 123456 function A() &#123; var num = 10;// 局部变量 return num;// 访问内部数据&#125;var B1 = A();console.log(B1);// 10 说明局部变量没有销毁 延长函数内部的局部变量的生命周期 上述代码可以在外部访问函数A内部的局部变量，并延长局部变量num的生命周期，但也有缺陷，每次访问都是一次性的，无法修改保存其变量如下代码所示： 12345678910function foo() &#123; var obj = &#123; name:&quot;张三&quot;, age:28 &#125;; return obj;&#125;var obj1 = foo();var obj2 = foo();console.log(obj1 == obj2); //false 上述代码所示两次访问的对象不是同一个console.log(obj1 == obj2); // false！ 03、全局变量私有化，减少全局变量污染 12345(function () &#123; window.onload = function () &#123;// 全局变量私有化 &#125;;&#125;)(); 123456(function () &#123; var d = document; var btn1 = d.getElementById(&apos;btn&apos;); var btn2 = d.getElementById(&apos;btn&apos;); var btn3 = d.getElementById(&apos;btn&apos;);&#125;)(); 05、更新复杂变量(可以对变量进行校验和判断，保证安全性和稳定性) 001、设置数据 12345678910function test() &#123; var str1 = &apos;字符串1&apos;; return function (str) &#123; str1 = str; // 设置数据 return str1; &#125;&#125;var test1 = test();console.log(test1(&apos;hello&apos;)); // helloconsole.log(test1()); // undefined 上述代码是设置数据，但并没有判断数据，由于函数调用时没有传参，所以结果是console.log(test1()); // undefined,我们还可以在其内部添加校验和判断，代码如下： 123456789101112function test() &#123; var str1 = &apos;字符串1&apos;; return function (str) &#123; if(typeof str == &apos;string&apos;)&#123;// 判断传参是不是string类型 str1 = str; // 设置数据 &#125; return str1; &#125;&#125;var test1 = test();console.log(test1(&apos;hello&apos;)); // helloconsole.log(test1()); // undefined 002、返回多个数据 - 以数组的形式返回 12345678910111213function person() &#123; var name = &quot;黄忠&quot;; var age = 45; return [function () &#123;//以数组的形式返回多个数据 return name; &#125;, function () &#123; return age; &#125;];&#125;var p1 = person();console.log(p1[0]()); // 黄忠console.log(p1[1]()); // 45 一般不怎么以数组的形式返回数据！ - 以对象的形式返回 123456789101112131415function person() &#123; var name = &quot;黄忠&quot;; var age = 45; return &#123; getName:function () &#123;//以对象的形式返回多个数据 return name; &#125;, getAge:function () &#123; return age; &#125; &#125;&#125;var p1 = person();console.log(p1.getName()); // 黄忠console.log(p1.getAge()); // 45 我们一般以这种形式返回多个数据！ 003、以对象形式返回多个数据并设置多个数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445function person() &#123; var name = &quot;黄忠&quot;; var age = 45; return &#123; getName:function () &#123;//以对象的形式返回多个数据 return name; &#125;, getAge:function () &#123; return age; &#125;, setName:function (value) &#123; //容错性处理 + 逻辑校验 //判断 if (typeof value != &apos;string&apos;) &#123; throw &quot;该函数只接受字符串类型的参数&quot;; &#125; name = value; &#125;, setAge:function (num) &#123; //容错性处理 + 逻辑校验 //判断 //console.log(num == NaN);// false //var str = String(num);// 把获取的实参转为字符串 //var str1 = String(NaN);// 把NaN转为字符串 //if ((str == str1) || typeof num != &apos;number&apos; ) //&#123;//判断输入的是否为数字类型并且不为NaN // throw &quot;该函数只接受数字类型的参数并且不为NaN&quot;; //&#125; //parseInt(num)数字为true，其他为false if (!(parseInt(num) || typeof num != &apos;number&apos; ) &#123;//parseInt(num)在会截取数字开头的字符串转为数字 || 所以还要判断类型 throw &quot;该函数只接受数字类型的参数并且不为NaN&quot;; &#125; age = num; &#125; &#125;&#125;var p1 = person();console.log(p1.getName()); // 黄忠console.log(p1.getAge()); // 45p1.setName(&apos;郭嘉&apos;);// 修改名字p1.setAge(28);// 修改年龄console.log(p1.getName()); // 郭嘉console.log(p1.getAge()); // 28 上述代码在返回的对象中多添加了setName方法和setAge方法,并在方法内部做了容错处理和校验判断，这样使代码的安全性和稳定性更好！ 四、闭包的应用场景1、for循环中 For循环中，for循环执行的速率非常快，有时候，我们希望保存变量i，用于其他地方。我们就可以用到闭包！代码如下： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;第一个&lt;/button&gt;&lt;button&gt;第二个&lt;/button&gt;&lt;button&gt;第三个&lt;/button&gt;&lt;button&gt;第四个&lt;/button&gt;&lt;button&gt;第五个&lt;/button&gt;&lt;script&gt; var btns = document.getElementsByTagName(&apos;button&apos;); //遍历按钮 for(var i= 0;i &lt; btns.length;i++)&#123; (function (a) &#123;// 保存在形参中 btns[a].onclick = function () &#123;// 按钮点击事件 每点击对应的按钮弹出对应的数字 alert(a+1); &#125; &#125;)(i) ;// 把i当作实参传进去 &#125; console.log(i);// 5 //在js中只有函数有作用域的概念&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 但上述代码中变量i是全局变量会影响其他的for循环，我们也可以用闭包把for循环包起来，防止全局变量污染！代码如下： 123456789101112var btns = document.getElementsByTagName(&apos;button&apos;);//遍历按钮(function () &#123; for(var i= 0;i &lt; btns.length;i++)&#123; (function (a) &#123;// 保存在形参中 btns[a].onclick = function () &#123;// 按钮点击事件 每点击对应的按钮弹出对应的数字 alert(a+1); &#125; &#125;)(i) ;// 把i当作实参传进去 &#125;&#125;)();console.log(i);// Uncaught ReferenceError: i is not defined // i 未定义 上述代码把for循环包起来，就把全局变量私有化了，外面就无法访问了，所以报错未定义。 2、在for循环中处理事件机制时我们经常用到闭包！ 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;第一个&lt;/button&gt;&lt;button&gt;第二个&lt;/button&gt;&lt;button&gt;第三个&lt;/button&gt;&lt;button&gt;第四个&lt;/button&gt;&lt;button&gt;第五个&lt;/button&gt;&lt;script&gt; var btns = document.getElementsByTagName(&apos;button&apos;); //遍历按钮 for(var i= 0;i &lt; btns.length;i++)&#123; btns[i].onclick = (function (a) &#123; return function () &#123; alert(a+1); &#125; &#125;)(i); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、在定时器中使用闭包 1234567for (var i = 0; i &lt; 10; i++) &#123; setTimeout((function (j) &#123; return function () &#123; console.log(j); &#125; &#125;)(i),1000);&#125; 五、结论闭包的原理:变量的访问原则(即上一级的作用域无法访问下一级的作用域),其实函数本身就是闭包","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript中的this关键字的用法和注意点","date":"2017-02-16T16:00:00.000Z","path":"2017/02/17/this/","text":"JavaScript中的this关键字的用法和注意点一、this关键字的用法this一般用于指向对象(绑定对象);01、在普通函数调用中，其内部的this指向全局对象(window);1234567function funcName()&#123; this.name = 'Jack'; console.log(this);// Window&#125;funcName();console.log(window.name);// Jackconsole.log(this.name);// Jack 上述代码先声明一个函数名为funcName的函数，给函数内部的对象添加属性name,并打印this的指向(window)，分别打印this的属性值和全局对象(window)的属性值，二者相等说明this指向全局对象(window); 02、在构造函数调用中，其内部的this指向新创建的对象1234567function Person() &#123; this.name = '郭嘉'; console.log(this);// Person &#123;name: \"郭嘉\"&#125;&#125;var p1 = new Person();console.log(p1.name); // 郭嘉console.log(window.name); // 空 上述代码先声明一个函数名为Person的构造函数，给构造函数内部的对象添加属性name,并打印this的指向(新创建的对象：Person {name: &quot;郭嘉&quot;})，用Person构造函数实例化一个对象p1,分别打印p1的属性值和全局对象(window)的属性值，二者不相等说明this指向的是新创建的对象(Person {name: &quot;郭嘉&quot;})而不是全局对象(window); 补充：使用new关键字创建构造函数的实例对象的系统内部流程1234567891011/*用new关键字创建构造函数的实例的系统内部流程*///001 使用new 关键字在内部默认创建一个对象//002 在构造函数内部,把默认创建的对象赋值给this//003 通过this来设置对象的属性和方法//004 默认把新创建的对象返回给我们function Person() &#123; //var this = new Object();//使用new 关键字在内部默认创建一个对象，并在构造函数内部,把默认创建的对象赋值给this this.name = '郭嘉';//通过this来设置对象的属性和方法 console.log(this);// Person &#123;name: \"郭嘉\"&#125; //return this;// 默认把新创建的对象返回给我们&#125; 03、在对象的方法调用中，其内部的this指向调用的对象本身12345678910//以对象的方法来进行调用var obj = &#123; name:\"张三\", // 对象的属性 getName:function () &#123; // 对象的方法 console.log(this);// Object &#123;name: \"张三\"&#125; &#125;&#125;;obj.getName();// 对象的方法调用console.log(obj.name); // 张三console.log(window.name);// 空 上述代码先声明一个对象名为obj的对象，给对象添加属性name,和方法getName,并在方法内部打印this的指向(对象本身：Object {name: &quot;张三&quot;}),调用对象的方法,打印this的指向是对象本身(Object {name: &quot;张三&quot;})而不是全局对象(window); 04、在事件处理中，其内部的this指向产生这个事件源的对象1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;button id='btn'&gt;click&lt;/button&gt;&lt;script&gt; var btn = document.getElementById('btn');// 获取id为btn的标签 btn.onclick = function () &#123;// 按钮点击事件 console.log(this);// &lt;button id='btn'&gt;click&lt;/button&gt; &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上述代码先用html创建一个按钮，再给这个按钮添加一个点击事件，并打印this的指向(&lt;button id =”btn”&gt;click&lt;/button&gt;),得出结论是this指向产生事件源的对象(&lt;button id =”btn”&gt;click&lt;/button&gt;); 05、在定时器中其内部的this指针指向window对象12345678910function Person() &#123; // 备份指针 console.log(this); // Person &#123;&#125; var self = this; setInterval(function () &#123; console.log(self);// Person &#123;&#125; console.log(this);// Window &#125;, 20);&#125;new Person(); 上述代码先创建一个person函数，再用self来备份一下this指针，再创建定时器，定时器内部的this永远指针指向window对象，有时候我们我们要用到指定的对象不是window对象，我们可以通过备份指针来实现； 06、通过call或者apply方式调用中(函数上下文),this指向的是当前的上下文，主要是改变this的指向call方法: 传入的参数数量不固定第一个参数是要绑定给this的值(即函数体内this对象的指向)第二个参数开始往后,每个参数都依次的传入作为函数的参数 apply: 接收两个参数第一个参数是要绑定给this的值(即函数体内this对象的指向)第二个就是一个参数数组12345678function Person() &#123; this.name = 'Jack';&#125;function Boy() &#123; Person.call(this); console.log(this);// Boy &#123;name: \"Jack\"&#125;&#125;var b1 = new Boy(); 上述代码创建两个构造函数Person和Boy，使用call方法让Person构造函数中的this指向Boy构造函数，相当于把Person构造函数内对象的属性和方法深拷贝一份(包括引用类型：指针和堆空间的数据) 1234567891011121314var obj = &#123; name:\"张三\", getName:function (param1,param2) &#123; console.log(this.name,param1,param2); &#125;&#125;obj.getName(\"123\",\"456\"); //张三 123 456var obj2 = &#123;name:\"李四\"&#125;;obj.getName.call(obj2); //打印李四 undefined undefinedobj.getName.call(obj2,\"测试字符串01\",\"测试的字符串02\"); // 李四 测试字符串01 测试的字符串02obj.getName.apply(obj2,[\"123\",\"456\"]); // 李四 123 456 上述代码先创建一个对象obj并添加属性name和方法getName,调用自身的方法得出的结果(张三 123 456),再创建一个对象obj2,添加属性name,obj.getName.call(obj2);这句话的意思是obj的方法getName借给obj2使用，其obj方法内部的this指向obj2;得出的结果是李四 undefined(没有传参) undefined(没有传参)；call方法主要是改变this的指向；apply的方法作用和call一样，只是传的参数不一样，call可以只传一个参数（要绑定给this的值），也可以传多个；而apply接收两个参数（要绑定给this的值，[]）,第二个参数是数组，数组的长度不定。 二、this关键字用法的注意点This的丢失问题12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"box\"&gt;&lt;/div&gt;&lt;script&gt; var box = document.getElementById('box');// 获取标签 var getId = document.getElementById;// var box = getId('box');// Uncaught TypeError: Illegal invocation (未捕获的类型错误) console.log(box);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上述代码先在html中创建一个id为box的div，然后再js中获取标签，有时候我们嫌获取标签的方法太长了，想要缩减一下(var getId = document.getElementById)，再调用，然而上述代码调用时则报错了！原因是方法内部的this指针丢失了，原先document.getElementById内部实现中用到this指针，其指向document对象，而getId调用时是按普通函数调用的，其内部的this指针指向window对象，所以执行到这一步的时候报错！ 现在用apply方法来修正this的指向12345678910111213//借用apply来修正thisdocument.getElementById = (function (func) &#123; return function () &#123; return func.apply(document,arguments); &#125;&#125;)(document.getElementById);var getId = document.getElementById;/*上句代码等同于下面这句代码var getId = function () &#123; return document.getElementById.apply(document,arguments);&#125;*/var box = getId('box'); //不会报错console.log(box);// &lt;div id=\"box\"&gt;&lt;/div&gt; 上述代码先在document.getElementById方法内部添加一个让this指针一直指向document对象的操作;document.getElementById =(function(func){})(document.getElementById);这是一个立即执行函数，把document.getElementById当作实参传进去，而函数内部则返回另一个函数，而这个函数内部则执行改变this指向的操作document.getElementById.apply(document,arguments);意思是让this永远指向document对象；arguments指的是传进去的实参Id(box); 三、结论This关键字永远指向实际调用者","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]}]